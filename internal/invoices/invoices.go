package invoices

import (
	"database/sql"
	"encoding/json"
	"fmt"
	sq "github.com/Masterminds/squirrel"
	"github.com/jmoiron/sqlx"
	"time"
)

type Invoice struct {
	CreationDate      *time.Time `json:"creation_date" db:"creation_date"`
	SettleDate        *time.Time `json:"settle_date" db:"settle_date"`
	AddIndex          uint64     `json:"add_index" db:"add_index"`
	SettleIndex       *uint64    `json:"settle_index" db:"settle_index"`
	PaymentRequest    *string    `json:"payment_request" db:"payment_request"`
	DestinationPubKey *string    `json:"destination_pub_key" db:"destination_pub_key"`
	RHash             *string    `json:"r_hash" db:"r_hash"`
	RPreimage         *string    `json:"r_preimage" db:"r_preimage"`
	Memo              *string    `json:"memo" db:"memo"`
	Value             *float64   `json:"value" db:"value"`
	AmountPaid        *float64   `json:"amt_paid" db:"amt_paid"`
	InvoiceState      *string    `json:"invoice_state" db:"invoice_state"`
	IsRebalance       *bool      `json:"is_rebalance" db:"is_rebalance"`
	IsKeysend         *bool      `json:"is_keysend" db:"is_keysend"`
	IsAmp             *bool      `json:"is_amp" db:"is_amp"`
	PaymentAddr       *string    `json:"payment_addr" db:"payment_addr"`
	FallbackAddr      *string    `json:"fallback_addr" db:"fallback_addr"`
	UpdatedOn         *time.Time `json:"updated_on" db:"updated_on"` // Generated by Torq if the status has changed
	Expiry            *uint32    `json:"expiry" db:"expiry"`
	CltvExpiry        *uint32    `json:"cltv_expiry" db:"cltv_expiry"`
	Private           *bool      `json:"private" db:"private"`
}

func getInvoices(db *sqlx.DB, filter sq.Sqlizer, order []string, limit uint64, offset uint64) (r []*Invoice,
	total uint64, err error) {

	qb := sq.Select("*").FromSelect(sq.Select(`
				distinct add_index,
				creation_date,
				settle_date,
				settle_index,
				invoice.payment_request,
				invoice.destination_pub_key,
				r_hash,
				r_preimage,
				memo,
				(invoice.value_msat/1000) as value,
				(invoice.amt_paid_msat/1000) as amt_paid,
				invoice_state,
    			coalesce(invoice.r_hash = p.payment_hash, false) as is_rebalance,
				is_keysend,
				is_amp,
				payment_addr,
				fallback_addr,
				invoice.updated_on,
				expiry,
				cltv_expiry,
				private
			`).From("invoice").LeftJoin("payment p on (invoice.r_hash = p.payment_hash)"), "subq").
		PlaceholderFormat(sq.Dollar).
		Where(filter).
		OrderBy(order...).
		Prefix(`WITH
			tz AS (select preferred_timezone as tz from settings),
			pub_keys as (select array_agg(pub_key) from local_node)
		`)

	if limit > 0 {
		qb = qb.Limit(limit).Offset(offset)
	}

	qs, args, err := qb.ToSql()
	if err != nil {
		return nil, 0, err
	}

	fmt.Println(qs, args)

	rows, err := db.Queryx(qs, args...)
	if err != nil {
		return nil, 0, err
	}

	for rows.Next() {
		var i Invoice
		err = rows.Scan(
			&i.AddIndex,
			&i.CreationDate,
			&i.SettleDate,
			&i.SettleIndex,
			&i.PaymentRequest,
			&i.DestinationPubKey,
			&i.RHash,
			&i.RPreimage,
			&i.Memo,
			&i.Value,
			&i.AmountPaid,
			&i.InvoiceState,
			&i.IsRebalance,
			&i.IsKeysend,
			&i.IsAmp,
			&i.PaymentAddr,
			&i.FallbackAddr,
			&i.UpdatedOn,
			&i.Expiry,
			&i.CltvExpiry,
			&i.Private,
		)

		if err != nil {
			return nil, 0, err
		}

		r = append(r, &i)

	}

	totalQb := sq.Select("count(*) as total").
		PlaceholderFormat(sq.Dollar).
		FromSelect(
			sq.Select(`
				distinct add_index,
				creation_date,
				settle_date,
				settle_index,
				invoice.payment_request,
				invoice.destination_pub_key,
				r_hash,
				r_preimage,
				memo,
				(invoice.value_msat/1000) as value,
				(invoice.amt_paid_msat/1000) as amt_paid,
				invoice_state,
    			coalesce(invoice.r_hash = p.payment_hash, false) as is_rebalance,
				is_keysend,
				is_amp,
				payment_addr,
				fallback_addr,
				invoice.updated_on,
				expiry,
				cltv_expiry,
				private
			`).From("invoice").LeftJoin("payment p on (invoice.r_hash = p.payment_hash)"), "subquery").
		Where(filter).
		Prefix(`WITH
			tz AS (select preferred_timezone as tz from settings),
			pub_keys as (select array_agg(pub_key) from local_node)
		`)

	totalQs, args, err := totalQb.ToSql()
	if err != nil {
		return nil, 0, err
	}

	err = db.QueryRowx(totalQs, args...).Scan(&total)
	if err != nil {
		return nil, 0, err
	}

	return r, total, nil

}

type Htlc struct {
	State             *uint64 `json:"state" db:"state"`
	LNDShortChannelId *uint64 `json:"chan_id" db:"lnd_short_channel_id"`
	Amt               *uint64 `json:"amt" db:"amt"`
	HtlcIndex         *uint64 `json:"htlc_index" db:"htlc_index"`
	AcceptTime        *uint64 `json:"accept_time" db:"accept_time"`
	ResolveTime       *uint64 `json:"resolve_time" db:"resolve_time"`
	AcceptHeight      *uint64 `json:"accept_height" db:"accept_height"`
	ExpiryHeight      *uint64 `json:"expiry_height" db:"expiry_height"`
	MppTotalAmt       *uint64 `json:"mpp_total_amt" db:"mpp_total_amt"`
}

type Feature struct {
	Name       *string `json:"name" db:"name"`
	IsKnown    *bool   `json:"is_known" db:"is_known"`
	IsRequired *bool   `json:"is_required" db:"is_required"`
}

type FeatureMap map[string]Feature

type InvoiceDetails struct {
	Invoice
	DescriptionHash []byte       `json:"description_hash" db:"description_hash"`
	Htlcs           []Htlc       `json:"htlcs" db:"htlcs"`
	Features        FeatureMap   `json:"features" db:"features"`
	RouteHints      []RouteHints `json:"route_hints" db:"route_hints"`
}

type HopHint struct {
	LNDShortChannelId *uint64 `json:"chan_id" db:"lnd_short_channel_id"`
	NodeId            *string `json:"node_id" db:"node_id"`
	FeeBase           *uint64 `json:"fee_base" db:"fee_base"`
	CltvExpiryDelta   *uint64 `json:"cltv_expiry_delta" db:"cltv_expiry_delta"`
	FeeProportional   *uint64 `json:"fee_proportional_millionths" db:"fee_proportional_millionths"`
}

type RouteHints struct {
	HopHints []HopHint `json:"hop_hints" db:"hop_hints"`
}

type ErrInvoiceNotFound struct {
	Identifier string
}

func (e ErrInvoiceNotFound) Error() string {
	return "Invoice not found"
}

func getInvoiceDetails(db *sqlx.DB, identifier string) (*InvoiceDetails, error) {

	//language=PostgreSQL
	qb := sq.Select(`
			distinct add_index,
			creation_date,
			settle_date,
			settle_index,
			invoice.payment_request,
			invoice.destination_pub_key,
			r_hash,
			r_preimage,
			memo,
			(invoice.value_msat/1000) as value,
			(invoice.amt_paid_msat/1000) as amt_paid,
			invoice_state,
			coalesce(invoice.r_hash = p.payment_hash, false) as is_rebalance,
			is_keysend,
			is_amp,
			payment_addr,
			fallback_addr,
			invoice.updated_on,
			expiry,
			cltv_expiry,
			private,
			description_hash,
			htlcs,
			features,
			route_hints
			`).
		PlaceholderFormat(sq.Dollar).
		From("invoice").
		LeftJoin("payment p on (invoice.r_hash = p.payment_hash)").
		Where(
			sq.Or{
				sq.Eq{"r_hash": identifier},
				sq.Eq{"r_preimage": identifier},
				sq.Eq{"payment_request": identifier},
			}).
		Prefix(`WITH
			tz AS (select preferred_timezone as tz from settings),
			pub_keys as (select array_agg(pub_key) from local_node)
		`)

	qs, args, err := qb.ToSql()
	i := InvoiceDetails{}
	var h []byte
	var fm []byte
	var rh []byte

	err = db.QueryRowx(qs, args...).Scan(
		&i.AddIndex,
		&i.CreationDate,
		&i.SettleDate,
		&i.SettleIndex,
		&i.PaymentRequest,
		&i.DestinationPubKey,
		&i.RHash,
		&i.RPreimage,
		&i.Memo,
		&i.Value,
		&i.AmountPaid,
		&i.InvoiceState,
		&i.IsKeysend,
		&i.IsAmp,
		&i.PaymentAddr,
		&i.FallbackAddr,
		&i.UpdatedOn,
		&i.CltvExpiry,
		&i.Expiry,
		&i.Private,
		&i.DescriptionHash,
		&h,
		&fm,
		&rh,
	)
	switch err {
	case nil:
		break
	case sql.ErrNoRows:
		return nil, ErrInvoiceNotFound{identifier}
	default:
		return nil, err
	}

	// Unmarshal the HTLCs
	err = json.Unmarshal(h, &i.Htlcs)
	if err != nil {
		return nil, err
	}

	// Unmarshal the feature map
	err = json.Unmarshal(fm, &i.Features)
	if err != nil {
		return nil, err
	}

	// Unmarshal the route hints
	err = json.Unmarshal(rh, &i.RouteHints)
	if err != nil {
		return nil, err
	}

	return &i, nil
}
