package invoices

import (
	"database/sql"
	"encoding/json"
	"fmt"
	sq "github.com/Masterminds/squirrel"
	"github.com/jmoiron/sqlx"
	"time"
)

type Invoice struct {
	CreationDate      *time.Time `json:"creation_date" db:"creation_date"`
	SettleDate        *time.Time `json:"settle_date" db:"settle_date"`
	AddIndex          *uint64    `json:"add_index" db:"add_index"`
	SettleIndex       *uint64    `json:"settle_index" db:"settle_index"`
	PaymentRequest    *string    `json:"payment_request" db:"payment_request"`
	DestinationPubKey *string    `json:"destination_pub_key" db:"destination_pub_key"`
	RHash             *string    `json:"r_hash" db:"r_hash"`
	RPreimage         *string    `json:"r_preimage" db:"r_preimage"`
	Memo              *string    `json:"memo" db:"memo"`
	ValueMsat         *string    `json:"value_msat" db:"value_msat"`
	AmountPaidMsat    *string    `json:"amt_paid_msat" db:"amt_paid_msat"`
	InvoiceState      *string    `json:"invoice_state" db:"invoice_state"`
	IsRebalance       *bool      `json:"is_rebalance" db:"is_rebalance"`
	IsKeysend         *bool      `json:"is_keysend" db:"is_keysend"`
	IsAmp             *bool      `json:"is_amp" db:"is_amp"`
	PaymentAddr       *string    `json:"payment_addr" db:"payment_addr"`
	FallbackAddr      *string    `json:"fallback_addr" db:"fallback_addr"`
	UpdatedOn         *time.Time `json:"updated_on" db:"updated_on"` // Generated by Torq if the status has changed
	Expiry            *uint32    `json:"expiry" db:"expiry"`
	CltvExpiry        *uint32    `json:"cltv_expiry" db:"cltv_expiry"`
	Private           *bool      `json:"private" db:"private"`
}

func getInvoices(db *sqlx.DB, filter sq.Sqlizer, order []string, limit uint64, offset uint64) (r []*Invoice,
	err error) {

	qb := sq.Select("*").FromSelect(sq.Select(`
				creation_date,
				settle_date,
				add_index,
				settle_index,
				payment_request,
				destination_pub_key,
				r_hash,
				r_preimage,
				memo,
				value_msat,
				amt_paid_msat,
				invoice_state,
				destination_pub_key = ANY(ARRAY[(table pub_keys)]) as is_rebalance,
				is_keysend,
				is_amp,
				payment_addr,
				fallback_addr,
				updated_on,
				expiry,
				cltv_expiry,
				private
			`).From("invoice"), "subq").
		PlaceholderFormat(sq.Dollar).
		Where(filter).
		OrderBy(order...).
		Limit(limit).
		Offset(offset).
		Prefix(`WITH
			tz AS (select preferred_timezone as tz from settings),
			pub_keys as (select array_agg(pub_key) from local_node)
		`)

	qs, args, err := qb.ToSql()
	if err != nil {
		return nil, err
	}

	fmt.Println(qs, args)

	rows, err := db.Queryx(qs, args...)
	if err != nil {
		return nil, err
	}

	for rows.Next() {
		var i Invoice
		err = rows.Scan(
			&i.CreationDate,
			&i.SettleDate,
			&i.AddIndex,
			&i.SettleIndex,
			&i.PaymentRequest,
			&i.DestinationPubKey,
			&i.RHash,
			&i.RPreimage,
			&i.Memo,
			&i.ValueMsat,
			&i.AmountPaidMsat,
			&i.InvoiceState,
			&i.IsRebalance,
			&i.IsKeysend,
			&i.IsAmp,
			&i.PaymentAddr,
			&i.FallbackAddr,
			&i.UpdatedOn,
			&i.Expiry,
			&i.CltvExpiry,
			&i.Private,
		)

		if err != nil {
			return nil, err
		}

		r = append(r, &i)

	}
	return r, nil

}

type Htlc struct {
	State           *uint64 `json:"state" db:"state"`
	ChanId          *uint64 `json:"chan_id" db:"chan_id"`
	AmtMsat         *uint64 `json:"amt_msat" db:"amt_msat"`
	HtlcIndex       *uint64 `json:"htlc_index" db:"htlc_index"`
	AcceptTime      *uint64 `json:"accept_time" db:"accept_time"`
	ResolveTime     *uint64 `json:"resolve_time" db:"resolve_time"`
	AcceptHeight    *uint64 `json:"accept_height" db:"accept_height"`
	ExpiryHeight    *uint64 `json:"expiry_height" db:"expiry_height"`
	MppTotalAmtMsat *uint64 `json:"mpp_total_amt_msat" db:"mpp_total_amt_msat"`
}

type Feature struct {
	Name       *string `json:"name" db:"name"`
	IsKnown    *bool   `json:"is_known" db:"is_known"`
	IsRequired *bool   `json:"is_required" db:"is_required"`
}

type FeatureMap map[string]Feature

type InvoiceDetails struct {
	Invoice
	DescriptionHash []byte       `json:"description_hash" db:"description_hash"`
	Htlcs           []Htlc       `json:"htlcs" db:"htlcs"`
	Features        FeatureMap   `json:"features" db:"features"`
	RouteHints      []RouteHints `json:"route_hints" db:"route_hints"`
}

type HopHint struct {
	ChanId          *uint64 `json:"chan_id" db:"chan_id"`
	NodeId          *string `json:"node_id" db:"node_id"`
	FeeBaseMsat     *uint64 `json:"fee_base_msat" db:"fee_base_msat"`
	CltvExpiryDelta *uint64 `json:"cltv_expiry_delta" db:"cltv_expiry_delta"`
	FeeProportional *uint64 `json:"fee_proportional_millionths" db:"fee_proportional_millionths"`
}

type RouteHints struct {
	HopHints []HopHint `json:"hop_hints" db:"hop_hints"`
}

type ErrInvoiceNotFound struct {
	Identifier string
}

func (e ErrInvoiceNotFound) Error() string {
	return "Invoice not found"
}

func getInvoiceDetails(db *sqlx.DB, identifier string) (*InvoiceDetails, error) {

	//language=PostgreSQL
	qb := sq.Select(`
			creation_date,
			settle_date,
			add_index,
			settle_index,
			payment_request,
			destination_pub_key,
			r_hash,
			r_preimage,
			memo,
			value_msat,
			amt_paid_msat,
			invoice_state,
			is_keysend,
			is_amp,
			payment_addr,
			fallback_addr,
			updated_on,
			expiry,
			cltv_expiry,
			private,
			description_hash,
			htlcs,
			features,
			route_hints
			`).
		PlaceholderFormat(sq.Dollar).
		From("invoice").
		Where(
			sq.Or{
				sq.Eq{"r_hash": identifier},
				sq.Eq{"r_preimage": identifier},
				sq.Eq{"payment_request": identifier},
			}).
		Prefix(`WITH
			tz AS (select preferred_timezone as tz from settings),
			pub_keys as (select array_agg(pub_key) from local_node)
		`)

	qs, args, err := qb.ToSql()
	i := InvoiceDetails{}
	var h []byte
	var fm []byte
	var rh []byte

	err = db.QueryRowx(qs, args...).Scan(
		&i.CreationDate,
		&i.SettleDate,
		&i.AddIndex,
		&i.SettleIndex,
		&i.PaymentRequest,
		&i.DestinationPubKey,
		&i.RHash,
		&i.RPreimage,
		&i.Memo,
		&i.ValueMsat,
		&i.AmountPaidMsat,
		&i.InvoiceState,
		&i.IsKeysend,
		&i.IsAmp,
		&i.PaymentAddr,
		&i.FallbackAddr,
		&i.UpdatedOn,
		&i.CltvExpiry,
		&i.Expiry,
		&i.Private,
		&i.DescriptionHash,
		&h,
		&fm,
		&rh,
	)
	switch err {
	case nil:
		break
	case sql.ErrNoRows:
		return nil, ErrInvoiceNotFound{identifier}
	default:
		return nil, err
	}

	// Unmarshal the HTLCs
	err = json.Unmarshal(h, &i.Htlcs)
	if err != nil {
		return nil, err
	}

	// Unmarshal the feature map
	err = json.Unmarshal(fm, &i.Features)
	if err != nil {
		return nil, err
	}

	// Unmarshal the route hints
	err = json.Unmarshal(rh, &i.RouteHints)
	if err != nil {
		return nil, err
	}

	return &i, nil
}
